# 项目进展

Sanmill 项目衍生自 NineChess 项目，在 NineChess 基础上，主要进行了如下优化：

* 实现了可用的置换表

哈希表采用了 [kshk123 的实现](https://github.com/kshk123/hashMap)，并去除了无用的锁以及哈希桶。和 STL 自带的哈希表相比，key 的生成速度更快。轻量级的实现完全满足需求。

NineChess 使用 GetHashCode() 函数每次遍历棋盘所有点位，对效率有一定影响。Sanmill 的实现参考了象棋巫师的 [此文](https://www.xqbase.com/computer/struct_zobrist.htm) ，定义 Zobrist 数组。并参考 [此文](https://www.xqbase.com/computer/search_hashing.htm) 修改 alpha-beta 剪枝算法。

* 实现了内存池

搜索时生成的结点数量很多，执行 new 时性能不佳。故集成 [cacay 的内存池实现](https://github.com/cacay/MemoryPool) 建立内存池预分配内存，并在建立孩子结点时从内存池上分配。

* 使用自编写的 Stack 类取代 std::stack

对 stack 进行优化，使用自编写的 Stack 类取代 std::stack，内部实现基于静态数组，提升效率。

* 实现了着法排序

  - 当启用迭代加深时，每次迭代的最优招法排到下次迭代的首选招法。

  - 利用了人类知识，将棋盘点划分重要性，优先抢占高优先级的点位。而对于优先级相同的点位，使用随机排序，以避免人类按同样的赢旗线路反复获胜，提高可玩性。

  - 优先成三，其次堵对方的三。

* 不定长的搜索深度

  - 摆棋阶段对各个回合的搜索深度分别进行设定。刚开局搜索结点数多，而且走出缓招对局势影响不大，故调低深度，后面逐步加深，到邻近结尾时再调低，这是因为延深到走棋阶段后，因为吃子较多，搜索的结点数又会开始暴增，不宜搜索过深。
  
  - 走棋阶段动态调整深度。行棋阶段当双方棋子数量较多时增加搜索深度，行棋阶段如果双方子力相差悬殊则降低深度。

* 优化排序算法

使用 sqrt_sort_sort_ins 排序算法取代 std::sort, 提升效率。

* 三次重复局面算和棋

实现了三次重复局面算和棋，但规则尚未和国际象棋完全等同。

* 默认选择 “打三棋”

  修改了打三棋棋规，包括：

  - 多个三连只允许提一子；

  - 当前处于三连之中的子依然可以被提走。

* 增加了网络对战功能

  暂未稳定，对战时偶然会停止，概率约10盘出现1盘，较高。

* 增加了引擎对战功能

以便评估算法优化效果。

* 增强的历史记录

每次重新开局时自动记录棋谱保存到文件，文件名包含时间戳。

# 已知问题

* 迭代加深

参考 [此文](https://www.xqbase.com/computer/search_iterative.htm) 实现了迭代加深。不过步长设置为1时，有时迭代到奇数深度时会走出明显昏招，暂未调试。故暂时 关闭此功能。

* 局面评估

  九子棋的局面评估方法需完善，局面评估时需把棋子活动能力考虑在内。而十二子棋可以不考虑活动能力。

* 配置
  
目前把搜索深度暂时写死在代码里，界面上配置深度无效；
  
* 暂未完善水平线效应的处理

处理水平线效应，即当遇到吃子时搜索深度增加。由于吃子时本来搜索结点数就多，再多搜索一层就更慢了，故未开启。

* 其他待优化项

如果搜索时发现可选招法只有一个，就加深一层深度。这种情况在走棋阶段棋子很满时经常遇到。目前开启此功能后性能下降明显，待完善。

自动记忆输棋的局面，后续走棋时将对应的局面减少估值。目前开启后，一旦输棋，后面更容易走出昏招。

# 后续计划

* 集成 UCT 算法；
* 继续优化 Alpha-Beta 算法；
* 修复已知问题；
* 重构代码，剥离算法和 UI；
* 实现 App，计划使用 [Flutter](https://flutter.dev/) 开发，遵循 [Material Design](https://material.io/) 设计规范。App 为 Android/iOS 跨平台，调用 C++ 接口。前端部分同样开源，在 GPL 下发布。